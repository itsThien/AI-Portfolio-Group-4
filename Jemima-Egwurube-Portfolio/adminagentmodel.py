# -*- coding: utf-8 -*-
"""AdminAgent

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1xhMe0XlgEA-Eq61YCGeNROQC8O1pep1u

## Admin Agent
"""

!pip install openai python-dotenv

"""## 1. Imports & Basic Structures"""

from dataclasses import dataclass, field
from typing import Callable, Dict, List, Optional, Any
import uuid
import time
import random
import math
import re

"""## 2. Agent Architecture Skeleton"""

# ---- Task representation ----
@dataclass
class Task:
    id: str = field(default_factory=lambda: str(uuid.uuid4()))
    name: str = None
    description: str = None
    status: str = 'pending' # Changed default status from None to 'pending'
    dependencies: List[str] = field(default_factory=list)
    attempts: int = 0
    max_attempts: int = 3
    context: Dict[str, Any] = field(default_factory=dict)
    action: Optional[Callable[['Agent', 'Task'], None]] = None

    def is_ready(self, all_tasks: Dict[str, 'Task']) -> bool:
       """Task is ready if all dependencies are done and it's still pending."""
       if self.status != 'pending':
           return False
       return all(dep in all_tasks and all_tasks[dep].status == 'done' for dep in self.dependencies)

@dataclass
class Tool:
    name: str
    description: str
    func: Callable[..., Any]
# ---- Agent state / environment ----
class AgentEnvironment:
    """
    Simulated environment: calendar, docs, emails, logs.
    In real life, these would be APIs (Google Calendar, email service, etc.)
    """
    def __init__(self):
        self.calendar = []         # list of meetings
        self.documents = {}        # doc_id -> content
        self.emails = []           # list of sent emails
        self.followup_logs = []    # log entries
        self.busy_slots = set()    # simulate taken time slots

    def __repr__(self):
      return (f"<Env: {len(self.calendar)} meetings, "
              f"{len(self.documents)} docs, "
                f"{len(self.emails)} emails, "
                f"{len(self.followup_logs)} followups>")

# ---- Agent representation ----
class Agent:
    def __init__(self, name: str, environment: AgentEnvironment, log_file=None):
        self.name = name
        self.environment = environment
        self.tasks: Dict[str, Task] = {}
        self.history: List[str] = []
        self.log_file = log_file

        # Memory system
        self.short_term_memory: Dict[str, Any] = {}   # per-run
        self.long_term_memory: Dict[str, Any] = {     # across runs (simulated)
            "slot_failures": {},   # (date, time_slot) -> failure_count
        }
        # Tools
        self.tools: Dict[str, Tool] = {}

        # RL-ish reward log
        self.rewards: List[Dict[str, Any]] = []

    def log(self, message: str):
        print(f"[{self.name}] {message}")
        self.history.append(message)
        if self.log_file:
            self.log_file.write(f"[{self.name}] {message}\n")

    def report(self) -> str:
        """Generate a human-readable summary of what the agent did."""
        lines = ["=== AGENT REPORT ==="]
        lines.append(f"Name: {self.name}")
        lines.append(f"Tasks executed: {len(self.tasks)}")
        done = [t for t in self.tasks.values() if t.status == 'done']
        failed = [t for t in self.tasks.values() if t.status == 'failed']
        skipped = [t for t in self.tasks.values() if t.status == 'skipped']
        lines.append(f"Completed: {len(done)}, Failed: {len(failed)},Skipped: {len(skipped)} ")
        lines.append(f"Rewards: {len(self.rewards)}")
        lines.append(str(self.history[-5:]))

        return "\n".join(lines)

"""## 3. Safety Layer: Input Validation, Boundaries, Fallback"""

# Simple safety filter
FORBIDDEN_KEYWORDS = [
    "delete all data", "hack", "exploit", "ddos",
    "bypass security", "malware", "phishing"
]

def validate_input(goal: str) -> Dict[str, Any]:
    """
    Input Validation:
      - Block obviously harmful goals (toy examples)
      - Return structure with is_safe + reason
    """
    lowered = goal.lower()
    for keyword in FORBIDDEN_KEYWORDS:
        if keyword in lowered:
          return {"is_safe": False, "reason": f"Goal contains forbidden keyword: {keyword}"}
    if len(goal.strip()) == 0:
      return {"is_safe": False, "reason": "Goal is empty"}

    return {"is_safe": True, "reason": "Goal is safe"}

def boundary_enforced_goal(goal: str) ->bool:
    """
    Boundary Enforcement:
      Limit this agent to 'administrative / meeting' style goals.
    """
    allowed_keywords = ["meeting", "schedule", "kickoff", "agenda", "reminder", "follow-up"]
    return any(keyword in goal.lower() for keyword in allowed_keywords)

"""## 4. Tools: Calculator + Document Summary (with error handling)

### 4.1 Calculator tool (safe arithmetic)
"""

import ast
import operator as op

# Allowed operators for safe eveluation
ALLOWED_OPERATORS = {
    ast.Add: op.add,
    ast.Sub: op.sub,
    ast.Mult: op.mul,
    ast.Div: op.truediv,
    ast.Pow: op.pow,
    ast.USub: op.neg
}
def safe_eval(expr: str) -> float:
  """
    Very small safe calculator:
    parse expression and only allow numbers + basic arithmetic.
  """
  def eval_node(node):
    if isinstance(node, ast.Constant): # Use ast.Constant for numbers
      return node.value
    if isinstance(node, ast.UnaryOp) and type(node.op) in ALLOWED_OPERATORS:
      return ALLOWED_OPERATORS[type(node.op)](eval_node(node.operand))
    if isinstance(node, ast.BinOp) and type(node.op) in ALLOWED_OPERATORS:
      return ALLOWED_OPERATORS[type(node.op)](eval_node(node.left), eval_node(node.right))
    if isinstance(node, ast.Expression): # Handle Expression node if present
        return eval_node(node.body)
    raise ValueError("Unsupported expression")

  tree = ast.parse(expr, mode='eval').body
  return eval_node(tree)

def calculator_tool_func(expr: str) -> float:
    """A safe calculator tool for basic arithmetic."""
    try:
        return safe_eval(expr)
    except Exception as e:
        return f"Error evaluating expression: {e}"

"""### 4.2 Document summary tool"""

from collections import Counter

def simple_summarized(text: str, max_sentences: int) -> str:
    """
    Very basic extractive summary:
    - split into sentences
    - score by word frequency
    - take top N sentences
    """
    sentences = re.split(r'(?<=[.!?])\s+', text.strip())
    if len(sentences) <= max_sentences:
        return text

    words = re.findall(r'\w+', text.lower())
    word_freq = Counter(words)

    sentence_scores = {}
    for s in sentences:
        tokens = re.findall(r'\w+', s.lower())
        if not tokens:
            continue
        score = sum(word_freq[w] for w in tokens) / len(tokens)
        sentence_scores[s] = score

    # Filter out sentences that might not have scored
    ranked_sentences = sorted(sentence_scores.items(), key=lambda x: x[1], reverse=True)
    selected_sentences = [s for s, _ in ranked_sentences[:max_sentences]]

    return ' '.join(selected_sentences)

def document_summary_tool_func(text: str, max_sentences: int = 3) -> str:
  """A tool to summarize text into a specified number of sentences."""
  return simple_summarized(text, max_sentences)

"""## what the agent can actually do"""

# ---- Primitive actions the agent can take ----

class SlotUnavailableError(Exception):
    pass

def schedule_meeting(agent: Agent, task: Task):
    """
    Simulates scheduling a meeting.
    Expects in task.context:
      - date (str)
      - time_slot (str)
      - title (str)
      - attendees (list of emails)
    """
    ctx = task.context
    key = ctx.get('date'), ctx.get('time_slot')

    agent.log(f"Attempting to schedule meeting: {ctx['title']} at {key}")

    # Simulate a previously taken slot to force adaptation
    if key in agent.environment.busy_slots:
        agent.log("Time slot already taken. Raising SlotUnavailableError.")
        raise SlotUnavailableError(f"Slot {key} is already taken")

    # Random error injection to demonstrate retries (10% chance)
    if random.random() < 0.1:
      raise RuntimeError("Random scheduling API failure")

    agent.env.calendar.append({
        "title": ctx["title"],
        "date": ctx["date"],
        "time_slot": ctx["time_slot"],
        "attendees": ctx["attendees"]
        })
    agent.env.busy_slots.add(key)
    agent.log(f"Meeting scheduled successfully: {ctx['title']} at {key}")

def prepare_document(agent: Agent, task: Task):
    """
    Simulates preparing a document.
    Expects:
      - doc_title
      - doc_type
      - agenda_items (list)
    """
    ctx = task.context
    agent.log(f"Attempting to prepare document: {ctx['doc_title']} ({ctx['doc_type']})")

    content_lines = [
        f"Title: {ctx['doc_title']}",
        f"Type: {ctx['doc_type']}",
        "",
        "Agenda:",
    ]
    for i, item in enumerate(ctx['agenda_items'], start=1):
        content_lines.append(f"{i}. {item}")
    doc_id = str(uuid.uuid4())
    agent.env.documents[doc_id] = "\n".join(content_lines)
    agent.log(f"Document prepared successfully: {ctx['doc_title']} ({doc_id})")

    # Save doc_id into task.context so later tasks can reference it
    task.context['doc_id'] = doc_id
def send_reminder(agent: Agent, task: Task):
    """
    Simulates sending reminder emails.
    Expects:
      - attendees (list)
      - meeting_title
      - meeting_time (str)
    """
    ctx = task.context
    agent.log(f"Sending reminders for: {ctx['meeting_title']}")
    for attendee in ctx['attendees']:
      email = {
          "to": attendee,
          "subject": f"Reminder: {ctx['meeting_title']}",
          "body": f"Hi, this is a reminder for '{ctx['meeting_title']}' at {ctx['meeting_time']}."
        }
      agent.env.emails.append(email)
      agent.log(f"Reminder sent to: {attendee}")

def log_followup(agent: Agent, task: Task):
    """
    Simulates logging follow-up tasks after the meeting.
    Expects:
      - meeting_title
      - notes (str)
    """
    ctx = task.context
    agent.log(f"Logging followup for: {ctx['meeting_title']}")
    entry = {
        "meeting_title": ctx['meeting_title'],
        "notes": ctx["notes"],
        "timestamp": time.time()
    }
    agent.env.followup_logs.append(entry)
    agent.log(f"Followup logged for: {ctx['meeting_title']}")

"""## 5. Actions (Scheduling, Docs, Reminders, Follow-ups)"""

class SlotUnavailableError(Exception):
    pass

def give_reward(agent: Agent, task: Task, value: float, reason: str):
    agent.rewards.append({
        "task_id": task.id,
        "task_name": task.name,
        "value": value,
        "reason": reason,
        "timestamp": time.time()
    })

def use_tool_with_handling(agent: Agent, tool: Tool, *args, **kwargs) -> Dict[str, Any]:
    agent.log(f"Using tool: {tool.name}")
    try:
        result = tool.func(*args, **kwargs)
        agent.log(f"Tool {tool.name} succeeded. Result: {result}")
        return {"success": True, "result": result}
    except Exception as e:
        agent.log(f"Tool {tool.name} failed with error: {e}")
        return {"success": False, "error": str(e)}

def schedule_meeting(agent: Agent, task: Task):
    ctx = task.context
    key = (ctx["date"], ctx["time_slot"])

    agent.log(f"Attempting to schedule meeting: {ctx['title']} at {key}")

    # "RL-ish" policy: if this slot has failed many times in the past, avoid it
    fail_count = agent.long_term_memory["slot_failures"].get(key, 0)
    if fail_count >= 2:
        agent.log(f"Policy: avoiding historically bad slot {key} (failures={fail_count}).")
        backup = ctx.get("backup_time_slot")
        if backup:
            agent.log(f"Switching immediately to backup slot {backup}")
            key = (ctx["date"], backup)
            ctx["time_slot"] = backup

    # Simulate a taken slot
    if key in agent.environment.busy_slots: # Changed agent.env to agent.environment
        agent.log("Time slot already taken. Raising SlotUnavailableError.")
        raise SlotUnavailableError(f"Time slot {key} is unavailable")

    # Random API failure
    if random.random() < 0.1:
        raise RuntimeError("Random scheduling API failure")

    agent.environment.calendar.append({ # Changed agent.env to agent.environment
        "title": ctx["title"],
        "date": ctx["date"],
        "time_slot": ctx["time_slot"],
        "attendees": ctx["attendees"]
    })
    agent.environment.busy_slots.add(key) # Changed agent.env to agent.environment
    agent.log(f"Meeting scheduled successfully: {ctx['title']} at {key}")
    give_reward(agent, task, 1.0, "Meeting scheduled")


def prepare_document(agent: Agent, task: Task):
    ctx = task.context
    agent.log(f"Preparing document: {ctx['doc_title']} ({ctx['doc_type']})")

    content_lines = [
        f"Title: {ctx['doc_title']}",
        f"Type: {ctx['doc_type']}",
        "",
        "Agenda:",
    ]
    for i, item in enumerate(ctx.get("agenda_items", []), start=1):
        content_lines.append(f"{i}. {item}")

    # Example of using a tool: summarize agenda into a short blurb at top
    if "doc_summary" in agent.tools:
        summary_text = " ".join(ctx.get("agenda_items", []))
        tool_result = use_tool_with_handling(agent, agent.tools["doc_summary"], summary_text)
        if tool_result["success"]:
            content_lines.insert(0, "Summary: " + tool_result["result"])
        else:
            agent.log("Doc summary tool failed; continuing without summary.")

    doc_id = str(uuid.uuid4())
    agent.environment.documents[doc_id] = "\n".join(content_lines) # Changed agent.env to agent.environment
    agent.log(f"Document created with id: {doc_id}")
    task.context["doc_id"] = doc_id
    give_reward(agent, task, 0.5, "Document prepared")


def send_reminders(agent: Agent, task: Task):
    ctx = task.context
    agent.log(f"Sending reminders for: {ctx['meeting_title']}")

    for attendee in ctx["attendees"]:
        email = {
            "to": attendee,
            "subject": f"Reminder: {ctx['meeting_title']}",
            "body": f"Hi, this is a reminder for '{ctx['meeting_title']}' at {ctx['meeting_time']}."
        }
        agent.environment.emails.append(email) # Changed agent.env to agent.environment
        agent.log(f"Reminder sent to {attendee}")
    give_reward(agent, task, 0.5, "Reminders sent")


def log_followups(agent: Agent, task: Task):
    ctx = task.context
    agent.log(f"Logging follow-ups for: {ctx['meeting_title']}")
    entry = {
        "meeting_title": ctx["meeting_title"],
        "notes": ctx["notes"],
        "timestamp": time.time()
    }
    agent.environment.followup_logs.append(entry) # Changed agent.env.followup_log to agent.environment.followup_logs
    agent.log("Follow-up logged.")
    give_reward(agent, task, 0.3, "Follow-up logged")

"""### 6. Planner (Planning-then-Execution pattern)"""

def create_task(agent: Agent, name: str, description: str, action: Callable,
                dependencies: Optional[List[str]] = None,
                context: Optional[Dict[str, Any]] = None,
                max_attempts: int = 3) -> Task:
    task_id = str(uuid.uuid4())
    t = Task(
        id=task_id,
        name=name,
        description=description,
        action=action,
        dependencies=dependencies or [],
        context=context or {},
        max_attempts=max_attempts
    )
    agent.tasks[task_id] = t
    return t


def planning_then_execution_planner(agent: Agent, goal: str) -> List[Task]:
    """
    Planning-then-Execution:
    Step 1: Interpret goal (Input Processing)
    Step 2: Create an explicit plan (Task list + dependencies)
    """
    agent.log(f"[Planning] Goal received: {goal}")

    # INPUT PROCESSING: extract some simple parameters (toy)
    meeting_date = "2025-12-10"
    initial_time_slot = "10:00-11:00"
    backup_time_slot = "11:00-12:00"
    attendees = ["manager@example.com", "lead1@example.com", "lead2@example.com"]
    meeting_title = "Department Kickoff Meeting"

    agent.short_term_memory["meeting_config"] = {
        "date": meeting_date,
        "initial_time_slot": initial_time_slot,
        "backup_time_slot": backup_time_slot,
        "attendees": attendees,
        "title": meeting_title,
    }

    # PLAN: define tasks

    # 1. Schedule meeting
    t1 = create_task(
        agent,
        name="ScheduleMeeting",
        description="Schedule the department kickoff meeting.",
        action=schedule_meeting,
        context={
            "title": meeting_title,
            "date": meeting_date,
            "time_slot": initial_time_slot,
            "backup_time_slot": backup_time_slot,
            "attendees": attendees
        }
    )

    # 2. Prepare doc (depends on t1)
    t2 = create_task(
        agent,
        name="PrepareAgendaDoc",
        description="Prepare the meeting agenda document.",
        action=prepare_document,
        dependencies=[t1.id],
        context={
            "doc_title": f"{meeting_title} - Agenda",
            "doc_type": "agenda",
            "agenda_items": [
                "Welcome and introductions",
                "Department goals for the quarter",
                "Key projects and owners",
                "Q&A",
                "Next steps and action items"
            ]
        }
    )

    # 3. Send reminders (depends on t1 & t2)
    t3 = create_task(
        agent,
        name="SendReminders",
        description="Send calendar reminders to all attendees.",
        action=send_reminders,
        dependencies=[t1.id, t2.id],
        context={
            "meeting_title": meeting_title,
            "meeting_time": f"{meeting_date} {initial_time_slot}",
            "attendees": attendees
        }
    )

    # 4. Log followups (depends on t3)
    t4 = create_task(
        agent,
        name="LogFollowUps",
        description="Log follow-up tasks after the meeting.",
        action=log_followups,
        dependencies=[t3.id],
        context={
            "meeting_title": meeting_title,
            "notes": "Capture action items assigned during the kickoff."
        }
    )

    agent.log(f"[Planning] Planner created {len([t1,t2,t3,t4])} tasks.")
    return [t1, t2, t3, t4]

"""### 7. Execution Loop + Error Handling + RL Feedback"""

def print_task_summary(agent: Agent):
    print("\n=== TASK SUMMARY ===")
    for t in agent.tasks.values():
        deps = ",".join(t.dependencies) if t.dependencies else "-"
        print(f"{t.id[:8]} | {t.name:15} | {t.status:10} | deps: {deps}")
    print("====================\n")


def handle_task_error(agent: Agent, task: Task, error: Exception):
    agent.log(f"Error in task '{task.name}': {repr(error)}")

    # RL: negative reward for failure
    give_reward(agent, task, -1.0, f"Task failed with error: {repr(error)}")

    # Adaptation: special handling for SlotUnavailableError
    if isinstance(error, SlotUnavailableError):
        key = (task.context["date"], task.context["time_slot"])
        # increment failure count for policy improvement
        agent.long_term_memory["slot_failures"][key] = agent.long_term_memory["slot_failures"].get(key, 0) + 1

        backup = task.context.get("backup_time_slot")
        if backup and task.context.get("time_slot") != backup:
            agent.log(f"Adapting: changing meeting time from {task.context['time_slot']} to backup {backup}")
            task.context["time_slot"] = backup
        else:
            agent.log("No backup slot available or already used. Marking task as failed.")
            task.status = "failed"
            return

    # Generic retry logic
    task.attempts += 1
    if task.attempts >= task.max_attempts:
        agent.log(f"Max attempts reached for task '{task.name}'. Marking as failed.")
        task.status = "failed"
    else:
        agent.log(f"Will retry task '{task.name}' (attempt {task.attempts}/{task.max_attempts}).")
        task.status = "pending"


def execute_tasks(agent: Agent, max_iterations: int = 50):
    iteration = 0
    while iteration < max_iterations:
        iteration += 1
        agent.log(f"--- Iteration {iteration} ---")

        ready_tasks = [t for t in agent.tasks.values() if t.is_ready(agent.tasks)]

        if not ready_tasks:
            if all(t.status in ["done", "failed", "skipped"] for t in agent.tasks.values()):
                agent.log("No more tasks to run. Workflow complete.")
                break
            else:
                agent.log("No tasks are ready yet. Waiting...")
                time.sleep(0.3)
                continue

        for task in ready_tasks:
            agent.log(f"Starting task: {task.name}")
            task.status = "in_progress"
            try:
                if task.action is None:
                    raise RuntimeError("No action defined for this task.")
                task.action(agent, task)
                task.status = "done"
                agent.log(f"Task completed: {task.name}")
            except Exception as e:
                handle_task_error(agent, task, e)

        print_task_summary(agent)
    else:
        agent.log("Reached max iterations without completing all tasks.")


def propagate_failures(agent: Agent):
    failed_ids = {t.id for t in agent.tasks.values() if t.status == "failed"}
    changed = True
    while changed:
        changed = False
        for t in agent.tasks.values():
            if t.status == "pending":
                if any(dep in failed_ids for dep in t.dependencies):
                    agent.log(f"Skipping '{t.name}' because a dependency failed.")
                    t.status = "skipped"
                    failed_ids.add(t.id)
                    changed = True

"""### 8. High-Level run_goal Function (Safety + Transparency + Fallback)"""

def register_default_tools(agent: Agent):
    agent.tools["calculator"] = Tool(
        name="calculator",
        description="A safe calculator for basic arithmetic operations.",
        func=calculator_tool_func
    )
    agent.tools["doc_summary"] = Tool(
        name="doc_summary",
        description="Summarizes text into a specified number of sentences.",
        func=document_summary_tool_func
    )
    agent.log("Default tools registered.")

def run_goal_with_agent(goal: str):
    agent = Agent(name="DeptAdminAgent")
    register_default_tools(agent)

    agent.log("[Transparency] Starting new run.")
    agent.log(f"[Transparency] Received goal: '{goal}'")

    # Safety: input validation
    validation = validate_input(goal)
    if not validation["is_safe"]:
        agent.log(f"[Safety] Rejecting goal. Reason: {validation['reason']}")
        print("Agent response:")
        print("I can't safely fulfill that request. Reason:", validation["reason"])
        return agent

    # Boundary enforcement
    if not boundary_enforced_goal(goal):
        agent.log("[Boundary] Goal is outside my domain (admin/meetings).")
        print("Agent response:")
        print("I’m designed for administrative workflows like meetings, agendas, and reminders. "
              "Your request falls outside that scope, so I won’t act on it.")
        return agent

    # Reasoning: Planning-then-Execution
    planned_tasks = planning_then_execution_planner(agent, goal)

    print_task_summary(agent)

    # Execution with adaptation, error handling, RL-ish rewards
    execute_tasks(agent)
    propagate_failures(agent)

    # Output generation: human-readable report
    print(agent.report())
    print("\n=== Environment State ===")
    print(agent.environment) # Changed agent.env to agent.environment

    return agent

"""### 9. Simulate Busy Slot to Show Adaptation + Policy Improvement"""

import uuid
# Simulate a historically bad primary slot so we see adaptation
env_demo = AgentEnvironment() # Create an environment instance
agent_demo = Agent(name="DemoPreRun", environment=env_demo) # Pass the environment
# register_default_tools(agent_demo) # This function is not defined in the provided notebook state, commenting it out.
bad_slot = ("2025-12-10", "10:00-11:00")
agent_demo.environment.busy_slots.add(bad_slot) # Use .environment, not .env
agent_demo.long_term_memory["slot_failures"][bad_slot] = 2  # force policy to avoid it
# The original print statement triggered an AttributeError in AgentEnvironment's __repr__ due to a typo.
# We explicitly format the environment's state here to avoid calling the buggy __repr__.
print(f"Pre-run simulated environment: <Env: {len(agent_demo.environment.calendar)} meetings, "
      f"{len(agent_demo.environment.documents)} docs, "
      f"{len(agent_demo.environment.emails)} emails, "
      f"{len(agent_demo.environment.followup_logs)} followups>")

"""### 10. Run the Whole Thing"""

import datetime
import os

def run_goal_with_agent(goal: str):
    # Create a unique log file for each run
    log_filename = f"agent_log_{datetime.datetime.now().strftime('%Y%m%d_%H%M%S')}.txt"
    log_file_path = os.path.join(".", log_filename)

    with open(log_file_path, "w") as lf:
        agent_env = AgentEnvironment()
        agent = Agent(name="DeptAdminAgent", environment=agent_env, log_file=lf)
        register_default_tools(agent)

        agent.log("[Transparency] Starting new run.")
        agent.log(f"[Transparency] Received goal: '{goal}'")

        # Safety: input validation
        validation = validate_input(goal)
        if not validation["is_safe"]:
            agent.log(f"[Safety] Rejecting goal. Reason: {validation['reason']}")
            print("Agent response:")
            print("I can't safely fulfill that request. Reason:", validation["reason"])
            return agent

        # Boundary enforcement
        if not boundary_enforced_goal(goal):
            agent.log("[Boundary] Goal is outside my domain (admin/meetings).")
            print("Agent response:")
            print("I’m designed for administrative workflows like meetings, agendas, and reminders. "
                  "Your request falls outside that scope, so I won’t act on it.")
            return agent

        # Reasoning: Planning-then-Execution
        planned_tasks = planning_then_execution_planner(agent, goal)

        print_task_summary(agent)

        # Execution with adaptation, error handling, RL-ish rewards
        execute_tasks(agent)
        propagate_failures(agent)

        # Output generation: human-readable report
        report_content = agent.report()
        print(report_content)
        lf.write(report_content + "\n") # Write report to log file

        print("\n=== Environment State ===")
        env_state_str = (f"<Env: {len(agent.environment.calendar)} meetings, "
                         f"{len(agent.environment.documents)} docs, "
                         f"{len(agent.environment.emails)} emails, "
                         f"{len(agent.environment.followup_logs)} followups>")
        print(env_state_str)
        lf.write(f"\n=== Environment State ===\n{env_state_str}\n")

    print(f"Agent log saved to: {log_file_path}")

    return agent

goal = "Organize a department kickoff meeting and handle all scheduling, documentation, reminders, and follow-ups."
final_agent = run_goal_with_agent(goal)


print("\nCalendar:", final_agent.environment.calendar)
print("\nDocuments:", final_agent.environment.documents)
print("\nEmails:", final_agent.environment.emails)
print("\nFollowups:", final_agent.environment.followup_logs)
print("\nRewards log:")
for r in final_agent.rewards:
    print(r)